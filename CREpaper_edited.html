<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>crepaper_edited</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="CREpaper_edited_files/libs/clipboard/clipboard.min.js"></script>
<script src="CREpaper_edited_files/libs/quarto-html/quarto.js"></script>
<script src="CREpaper_edited_files/libs/quarto-html/popper.min.js"></script>
<script src="CREpaper_edited_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="CREpaper_edited_files/libs/quarto-html/anchor.min.js"></script>
<link href="CREpaper_edited_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="CREpaper_edited_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="CREpaper_edited_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="CREpaper_edited_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="CREpaper_edited_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<hr>
<p>title: “<code>cre</code> Simplifying the Application of Correlated Random Effects” format: pdf: documentclass: article author: - name: “Fernando Rios-Avila” affiliations: - name: “Levy Economics Institute” address: Annandale-on-Hudson, NY 12504 - name: “Aashima Sinha” affiliations: - name: “Levy Economics Institute” address: Annandale-on-Hudson, NY 12504 date: today abstract: | This paper introduces the <code>cre</code> command, a prefix type command, that helps in the implementation of Correlated Random Effects (CRE) estimator for linear and nonlinear models. For the linear case, CRE models offer a simple approach that combines the advantages of both fixed effects and random effects estimators, providing consistent estimates identical to the Fixed Effect estimator, but allowing for the identification of coefficients for time-invariant variables. For the nonlinear case, it provides an alternative to fixed effects estimators that may be difficult to implement or simply non-existent. The <code>cre</code> command provides a user-friendly approach for estimating these models, supporting both balanced and unbalanced panels, which can be applied to most linear and nonlinear estimators.</p>
<p>keywords: “Mundlak approach, correlated random effects, panel data”</p>
<p>bibliography: - references.bib —</p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Panel data analysis has become increasingly important in empirical research in economics and social sciences, allowing researchers to control for unobserved individual heterogeneity that is believed to be fixed across time. The two main approaches that have been used to model relationships using this type of data have been fixed effects (FE) and random effects (RE) models. Each one of them, however, comes with limitations. On the one hand, while fixed effects models can be used to provide consistent estimates, while controlling for time-invariant unobserved factors, they cannot be used to estimate the effects of time-invariant variables, which may be relevant for some research questions. On the other hand, while random effects models allow you to identify effects of time-invariant variables, the estimation relies on the strong assumption that individual-specific effects are uncorrelated with other explanatory variables in the model, which is often violated in practice <span class="citation" data-cites="wooldridge2019">[@wooldridge2019]</span>.</p>
<p>While less commonly used, there is a third option that shares some of the strengths of both FE and RE models: Correlated Random Effects (CRE) models. First introduced by <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span> and further developed by <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span>, CRE proposes a middle ground approach to address the limitations of RE models by explicitly allowing for correlation between the individual-specific effects and the time-varying explanatory variables. By doing so, CRE can estimate the effects of time-invariant variables while also providing consistent estimates for time-variant coefficients that are identical to the FE estimator in linear models. Despite these advantages, CRE models have seen limited use in applied research, partly due to the lack of readily available software implementations. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>This paper introduces the <code>cre</code> command for Stata, which aims to provide a straightforward and flexible tool for estimating CRE models for linear and non-linear models, supporting both balanced and unbalanced panels, as well as multiple fixed effects. This command is a prefix command that identifies all explanatory variables in a model, calculates the group means (or mean-like statistics) for each variable, and adds them to the model to provide a <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span> type estimator. Because of this, there are few restrictions on the type of models that can be estimated using this command, making it a versatile tool for applied researchers. Furthermore, because it integrates seamlessly with Stata’s existing estimation commands, all post-estimation commands and diagnostics can be used.</p>
<p>We begin in <a href="#sec-2" class="quarto-xref">Section&nbsp;2</a> reviewing the theoretical foundations of CRE models and their relationship to FE and RE models, extending our discussion to Multiple fixed effects, and application with non-linear models. <a href="#sec-3" class="quarto-xref">Section&nbsp;3</a> presents the implementation of CRE estimation in Stata, describing the syntax of the command. Finally, <a href="#sec-4" class="quarto-xref">Section&nbsp;4</a> presents a small Monte Carlo simulation to assess the performance of the CRE approach. <a href="#sec-5" class="quarto-xref">Section&nbsp;5</a> concludes.</p>
</section>
<section id="sec-2" class="level1">
<h1>Theoretical Framework</h1>
<section id="correlated-random-effects-models---1-dimension" class="level2">
<h2 class="anchored" data-anchor-id="correlated-random-effects-models---1-dimension">Correlated Random Effects Models - 1 Dimension</h2>
<p>The Correlated Random Effects (CRE) is an alternative estimation approach for panel data models that was first introduced by <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span> and further developed by <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span>. In contrast with standard Fixed Effects estimator, CRE allows users to control and identify the effects of time-variant and time-invariant variables. And, in contrast with standard random effects estimator, CRE lifts the assumption that individual-specific effects are uncorrelated with other explanatory variables in the model. As pointed out in <span class="citation" data-cites="wooldridge2010econometric">@wooldridge2010econometric</span>, for the case of linear models, the CRE point estimates are identical to the Fixed Effects estimator.</p>
<p>To understand how CRE models work, let’s consider the following data generating process:</p>
<p><span id="eq-cre-1"><span class="math display">\[y_{i,t} = \beta_0 + x_{i,t}\beta_x + z_{i}\beta_z  + \alpha_i + u_{i,t}
\tag{1}\]</span></span></p>
<p>where <span class="math inline">\(y_{i,t}\)</span> is the dependent variable for individual <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span>, <span class="math inline">\(x_{i,t}\)</span> is a vector of time-varying explanatory variables, <span class="math inline">\(z_i\)</span> a set of time-invariant factors, <span class="math inline">\(\alpha_i\)</span> is the individual-specific effect, and <span class="math inline">\(u_{i,t}\)</span> is the idiosyncratic error term.</p>
<p>Under the assumption that <span class="math inline">\(\alpha_i\)</span> is uncorrelated with <span class="math inline">\(x_{i,t}\)</span>, in addition to the standard assumption of exogeneity of <span class="math inline">\(u_{it}\)</span>, <a href="#eq-cre-1" class="quarto-xref">Equation&nbsp;1</a> could be consistently estimated using ordinary least squares (OLS), Random effects estimator, or fixed effects estimator.</p>
<p>In the case of using OLS, standard errors would need to be adjusted to account for the fact that <span class="math inline">\(\alpha_i\)</span> is an effect that is clustered within individuals. In the case of Fixed effects, if the panel data is balanced, one could simply demean all the variables with group individual means and estimate the model with the transformed data. This demeaning process would eliminate the individual-specific effect <span class="math inline">\(\alpha_i\)</span> from the model, but would also make it impossible to estimate the effects of time-invariant variables. In the case of random effects, one could quasi-demean the data, before estimating the model. This transformation eliminates the within-individual autocorrelation, allowing for the estimation of coefficients of time-invariant variables. However, this approach is not consistent if the assumption that <span class="math inline">\(\alpha_i\)</span> is uncorrelated with <span class="math inline">\(x_{i,t}\)</span> is violated.</p>
<p>The solution proposed by <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span> and <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span> was to explicitly allow for correlation between the individual-specific effects and the time-varying explanatory variables, by assuming that the individual-specific effect can be expressed as a projection of (mean) time-varying variables plus an uncorrelated disturbance. Specifically:</p>
<p><span id="eq-cre-2"><span class="math display">\[\begin{aligned}
Mundlak:  &amp; &amp; \alpha_i &amp;= \gamma_0 + \bar x_{i}\gamma + v_i &amp;  \\
Chamberlain: &amp; &amp; \alpha_i &amp;= \gamma_0 + x_{i,1}\gamma_1 + x_{i,2}\gamma_2 + \dots + x_{i,T}\gamma_T + v_i
\end{aligned}
\tag{2}\]</span></span></p>
<p>where <span class="math inline">\(\bar x_{i}\)</span> is the individual specific mean of the time-varying variables, <span class="math inline">\(x_{i,t}\)</span> is the realization of <span class="math inline">\(x\)</span> for individual <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(v_i\)</span> is an uncorrelated disturbance. The main difference between both approaches was that <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span> allowed for a more flexible specification of the correlation between the individual-specific effect and the time-varying variables. <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span>, on the other hand, assumed that the correlation was constant, only depending on the individual average. If we substitute <a href="#eq-cre-2" class="quarto-xref">Equation&nbsp;2</a> into <a href="#eq-cre-1" class="quarto-xref">Equation&nbsp;1</a>, the final model can be written as:</p>
<p><span id="eq-cre-final"><span class="math display">\[y_{i,t} = \beta_0 +x_{i,t}\beta_x + z_{i}\beta_z + \gamma_0 + f(x_{i,t})\Gamma + v_i + u_{i,t}
\tag{3}\]</span></span></p>
<p>where <span class="math inline">\(f(x_{i,t})\)</span> can be the full set of time-varying variables or just the average of them. Notice that in this specification, <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\gamma_0\)</span> cannot be independently identified, and that the new model now has a compound error <span class="math inline">\(v_i + u_{i,t}=\mu_{i,t}\)</span>, which is uncorrelated with <span class="math inline">\(x_{i,t}\)</span> by construction.</p>
<p>While this model could now be estimated using OLS, to account for the within-individual correlation driven by <span class="math inline">\(v_i\)</span>, the model should be estimated using either random effects estimator, or clustering standard errors at the individual level (see <span class="citation" data-cites="wooldridge2010econometric">@wooldridge2010econometric</span> for a discussion). Interestingly, both methods provide the same results for time-varying covariates if the panel data is balanced, and all covariates are strictly exogenous.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> However, this identity breaks down in other cases (see <span class="citation" data-cites="abrevaya2013">@abrevaya2013</span>).</p>
<p>While both approaches will produce consistent estimates for the time-varying covariates, the implementation of <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span> is more difficult when the panel data is unbalanced (see <span class="citation" data-cites="abrevaya2013">@abrevaya2013</span>). On the other hand, <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span> approach is easier to implement with unbalanced panels, because it only requires the calculation of the individual means for the observed data for each individual, as it has been shown by <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span>. Furthermore, <span class="citation" data-cites="mundlak1978pooling">@mundlak1978pooling</span> only requires adding a few covariates to the model regardless of the number of periods in the panel, compared to an increasing number of covariates in <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span> approach.</p>
</section>
<section id="correlated-random-effects-models---multiple-dimensions" class="level2">
<h2 class="anchored" data-anchor-id="correlated-random-effects-models---multiple-dimensions">Correlated Random Effects Models - Multiple Dimensions</h2>
<p>One potential advantage of CRE-Mundlak estimation that has been less discussed in the literature is that it can be easily extended to accommodate for multiple fixed effects/dimensions. In the standard case of panel data, for example, one may be interested in controlling for both individual and time fixed effects. Among the few papers discussing this extension, <span class="citation" data-cites="baltagi2023">@baltagi2023</span> focuses on formalizing the equivalence with two-way fixed effect estimation, while <span class="citation" data-cites="wooldridge2021">@wooldridge2021</span> have discussed the advantages of CRE-Mundlak estimation for the identification of treatment effects in setups of staggered adoption of treatments. Both authors discuss the CRE-Mundlak approach in the context of two fixed effects, however, the extension to more than two fixed effects is straightforward.</p>
<p>Consider the following data generating process:</p>
<p><span id="eq-mcre-1"><span class="math display">\[y_{i,t} = \beta_0 + x_{i,t}\beta_x + z_{i}\beta_z + w_{t}\beta_w + \alpha_i + \tau_t + u_{i,t}
\tag{4}\]</span></span></p>
<p>In addition to the components from <a href="#eq-cre-1" class="quarto-xref">Equation&nbsp;1</a>, <a href="#eq-mcre-1" class="quarto-xref">Equation&nbsp;4</a> also considers individual-invariant variables <span class="math inline">\(w_{t}\)</span>, as well as effects that only vary across time, but not individuals <span class="math inline">\(\tau_t\)</span>. As before, pool OLS or random effects estimators are only consistent if the individual-specific (<span class="math inline">\(\alpha_i\)</span>) and time-specific (<span class="math inline">\(\tau_i\)</span>) effects are uncorrelated with the explanatory variables. Without loss of generality let’s assume that all variables have an overall mean of zero.</p>
<p>Extending the analogy from <a href="#eq-cre-2" class="quarto-xref">Equation&nbsp;2</a>, we can project the sum of individual-specific and time-specific effect as a function of the individual and time averages of <span class="math inline">\(X's\)</span>. Other variables are not included because they already are invariant in one of the dimensions:</p>
<p><span id="eq-mcre-2"><span class="math display">\[
\alpha_i + \alpha_t  = \gamma_0 + \check x_{i}\gamma + \check x_{t}\delta + v_{i,t}
\tag{5}\]</span></span> Interestingly, if the panel data is balanced, <span class="math inline">\(\check x_{i}\)</span> and <span class="math inline">\(\check x_{t}\)</span> can be estimated simply as the individual or period specific average. Furthermore, they would be orthogonal and <a href="#eq-mcre-2" class="quarto-xref">Equation&nbsp;5</a> could be expressed using two equations like <a href="#eq-cre-2" class="quarto-xref">Equation&nbsp;2</a>, one for each dimension. In either case, the final model would be:</p>
<p><span id="eq-mcre-final"><span class="math display">\[y_{i,t} = \beta_0 + x_{i,t}\beta_x + z_{i}\beta_z + w_{t}\beta_w + \gamma_0 + \check x_{i}\gamma + \check x_{t}\delta+ v_{i,t} + u_{i,t}
\tag{6}\]</span></span></p>
<p>where <span class="math inline">\(v_{i,t}\)</span> is the compound error term (<span class="math inline">\(v_{i}+v_{t}\)</span>) that is uncorrelated with <span class="math inline">\(x_{i,t}\)</span>, which could be estimated using OLS. However, balanced panel data is not the norm.</p>
<p>When the panel data is unbalanced, <span class="math inline">\(\check x_{i}\)</span> and <span class="math inline">\(\check x_{t}\)</span> cannot be estimated as simple group averages. This is similar to the problem of using the within transformation for the estimation of M-way fixed effects (<span class="citation" data-cites="rios2015">@rios2015</span>, <span class="citation" data-cites="correia_2016">@correia_2016</span>).<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> In this case, instead of estimating <span class="math inline">\(\check x\)</span> as individual or group averages, one should estimate them as the solution to the following model:</p>
<p><span id="eq-mcre-3"><span class="math display">\[x_{i,t} = \check x_{i} + \check x_{t} + \epsilon_{i,t}
\tag{7}\]</span></span></p>
<p>Notice that we assume the constant to be zero, given the zero mean assumption. <span class="math inline">\(\check x_{i}\)</span> and <span class="math inline">\(\check x_{t}\)</span> in this model can be estimated using an iterative demeaning, as long as the sample used is the same one as in the original model (<a href="#eq-mcre-1" class="quarto-xref">Equation&nbsp;4</a>). In addition, one should only concentrate on variables that show variation in both dimensions. Once these are estimated, the final model can be estimated using <a href="#eq-mcre-final" class="quarto-xref">Equation&nbsp;6</a>.</p>
<p>Extending this analogy to three or more dimensions is straightforward. One simply requires to:</p>
<ol type="1">
<li>Define the sample that is common to all dimensions.</li>
<li>Estimate the group pseudo-averages for each dimension, and for all variables that show variation in all dimensions.</li>
<li>Include the new variables in the main model, and estimate that model using OLS.</li>
</ol>
</section>
<section id="nonlinear-models-and-cre" class="level2">
<h2 class="anchored" data-anchor-id="nonlinear-models-and-cre">Nonlinear Models and CRE</h2>
<p>While the CRE approach has some advantages over FE and RE in linear models, including the option for a robust test to choose between RE and FE models, unless one is interested in the effects of time-invariant variables, the incentives to use CRE over FE are minimal in the framework of linear models. However, as discussed in <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span> and <span class="citation" data-cites="wooldridge2023">@wooldridge2023</span>, CRE can be particularly important to provide an alternative to fixed effect estimation in non-linear models, where the simple inclusion of dummies is not possible due to the incidental parameter problem, and a fixed effect estimator is not available. In fact, <span class="citation" data-cites="wooldridge2010econometric">@wooldridge2010econometric</span> shows that the CRE approach applies to commonly used models, such as probit, tobit, and count models, among others.</p>
<p>Consider a data generating process for a non-linear model, where the latent linear index is given by:</p>
<p><span id="eq-nl-1"><span class="math display">\[y^*_{i,t} = \beta_0 + x_{i,t}\beta_x + z_{i}\beta_z + \alpha_i \\
\tag{8}\]</span></span></p>
<p>In this case, <span class="math inline">\(y^*\)</span> is the expected latent variable that depends on time varying and time invariant variables, as well as an individual-specific effect. The observed variable <span class="math inline">\(y_{i,t}\)</span> can then be generated as a random draw from a distribution that depends on <span class="math inline">\(y^*_{i,t}\)</span>. For example:</p>
<p><span class="math display">\[\begin{aligned}
\text{probit: } &amp;&amp; y_{i,t} &amp;= 1\{y^*_{i,t}+u_{i,t}&gt;0\} \text{ with } u_{i,t}\sim N(0,1) \\
\text{poisson: } &amp;&amp; y_{i,t} &amp; \sim  poisson(exp(y^*_{i,t})) \\
\text{tobit: } &amp;&amp; y_{i,t} &amp;= max(0, y^*_{i,t}+u_{i,t}) \text{ with } u_{i,t}\sim N(0,\sigma) \\
etc
\end{aligned}
\]</span></p>
<p>In all these cases, there is an explicit individual fixed component <span class="math inline">\(\alpha_i\)</span>, which may cause a bias on estimated coefficients if not accounted for. Furthermore, while estimating models with explicit fixed effects is possible for some models, like the poisson or logit, explicit fixed effects estimators are not available for probit or tobit models, among others, and simply including dummies for individual fixed effects does not yield consistent estimates due to the incidental parameter problem.</p>
<p><span class="citation" data-cites="wooldridge2019">@wooldridge2019</span> and <span class="citation" data-cites="wooldridge2010econometric">@wooldridge2010econometric</span> show that the CRE approach can be used to estimate these models consistently, by following the same logic as in the linear case. That is, estimate the group specific means for the time-varying variables and include them in the model specification, before the estimation of the non-linear model. The linear model could be directly estimated using pooled cross-section, and clustering standard errors at the panel level. In fact, this approach has been used in <span class="citation" data-cites="wooldridge2023">@wooldridge2023</span> to estimate treatment effects of staggered adoption of treatments in non-linear models, albeit concentrating on a single dimension (panel).</p>
<p>In this framework, <code>cre</code> has the additional advantage over other methods. Because one has explicit access to all the variables in the model, including the constructed variables, the estimation of partial effects can be done directly using available post-estimation commands such as <code>margins</code>. There are no other changes in the estimation process, and the strategy is easily extended to multiple fixed effects, as discussed in the previous section. Furthermore, as discussed in <span class="citation" data-cites="wooldridge2019">@wooldridge2019</span>, one can consider even more flexible specifications by allowing for interactions between the group-specific means and other variables in the model, including time dummy variables.</p>
</section>
</section>
<section id="sec-3" class="level1">
<h1><code>cre</code> Command: Implementation in Stata</h1>
<p>The <code>cre</code> command is a prefix command that estimates the CRE model for most linear and non-linear models in Stata. The syntax of the command is as follows:</p>
<p><code>cre, abs(varlist) [options]: [estimation command] [variables] [if in] [weights], [options]</code></p>
<p>Where <code>estimation command</code> is the command that will be used to estimate the model. In this case, the <code>cre</code> command will identify all the dependent variables in the model, along with other sample restrictions, and calculate conditional group means based on the groups defined by the <code>abs(varlist)</code>. The group means are then added to the model before estimation. The <code>cre</code> command supports both balanced and unbalanced panels, as well as multiple fixed effects relying on <code>reghdfe</code> for the estimation of the pseudo conditional means.</p>
<p>A detailed list of other options include:</p>
<ul>
<li><code>abs(varlist)</code>: a list of variables that define the groups for which the conditional means will be calculated. This can be a single variable or a combination of variables.</li>
<li><code>drop</code>: if specified, the command will drop the group means variables from the dataset after estimation.</li>
<li><code>dropsingletons</code>: if specified, the command will drop observations that have a single observation in any given group. Note that <code>reghdfe</code> default is to drop these observations, rather than keep them as in this case.</li>
<li><code>prefix</code>: provides a prefix to be used to name the group means variables. The default uses “<code>m</code>” as a prefix. For every variable that has variation across all groups defined in <code>abs(varlist)</code>, the command will create a new variable with the prefix followed by the variable name. <code>m1_x</code>, <code>m2_x</code>, etc, corresponding to the group means for variable <code>x</code> for the first, second, etc group defined in <code>abs(varlist)</code>. Note that when trying to estimate means for interaction terms, the command will attempt to name the new variable using Stata guidelines for variable names. If the variable name is too long, the command will create a generic name <code>_v#</code>.</li>
<li><code>hdfe(options)</code>: options to be passed to <code>reghdfe</code> command. This can be used to make better use of alternative speed-up options in <code>reghdfe</code>.</li>
</ul>
<p>In addition to the standard information left by the estimation command, the <code>cre</code> will add the list of group mean variables created for the estimation in <code>e(m_list)</code>.</p>
<p>The command has been tested for most 1 and 2 word commands, and after <code>ivreg</code> and <code>ivregress</code> commands. However, for unsupported commands, an alternative approach would be to use <code>cre</code> for a fully specified model, and then use the command of interest including the group means variables manually in the model.</p>
</section>
<section id="sec-4" class="level1">
<h1>Monte Carlo Simulations</h1>
<p>To assess the performance of the <code>cre</code> command, we conducted a Monte Carlo simulation study. Instead of focusing on a model with a single fixed effect, we considered a case with two unobserved fixed effects, which allows for a structure of unbalanced panels. Without loss of generality, we also consider a model with 2 explanatory variables that are correlated with the unobserved fixed effects, but are otherwise exogenous. Finally, we consider that the expected latent variable is a linear function of the explanatory variables and fixed effects. The data generating process is as follows:</p>
<pre><code>set obs 1000
// Generates indicators for the two fixed effects
gen id1 = runiformint(1,100)
gen id2 = runiformint(1,100)
// fixed effects are assumed follow a uniform distribution
gen c1 = runiform(-.5,.5)
gen c2 = runiform(-.5,.5)
bysort id1:replace c1 = c1[1]
bysort id2:replace c2 = c2[1] 
// explanatory variables are correlated with the fixed effects, 
// thus correlated with each other
gen x1 = runiform(-1,1)+invnormal(c1+.5)+invnormal(c2+.5)
gen x2 = runiform(-1,1)-invnormal(c1+.5)-invnormal(c2+.5)
// and the expected latent ey_star is a linear combination x1, x2, c1, and c2
gen y_star = 1 + x1 + x2 + c1 + c2</code></pre>
<p>Since the equivalence between FE and CRE has been shown for linear models, we focus on the performance of the <code>cre</code> in the context of non-linear models. For this, we consider 4 different models: probit, fractional regression probit, tobit, and poisson.</p>
<p>For each one, the data generating process is as follows:</p>
<pre><code>// probit
gen y_probit = 1*(y_star-1+rnormal()&gt;0)
// fractional probit
gen y_fprobit = normal(y_star-1+rnormal())
// tobit
gen y_tobit = max( y_star + rnormal(),0)
// poisson
gen y_poisson = rpoisson(exp(y_star))</code></pre>
<p>We then estimate the models under three assumptions: one where the fixed effects are observed including <code>c1</code> and <code>c2</code> in the specification (benchmark), one where they are not considered, and one where we use the CRE approach using the <code>cre</code> command. This exercise is repeated 1000 times, and the results are compared in terms of the distributions of the marginal effects for the probit and fractional probit model, and coefficients for the tobit and poisson models, under the three scenarios. We use <code>parallel</code><span class="citation" data-cites="vegayon2019">[@vegayon2019]</span> to speed up the process.</p>
<p>The results of the simulation are presented in <a href="#fig-cre" class="quarto-xref">Figure&nbsp;1</a> and <a href="#tbl-cre" class="quarto-xref">Table&nbsp;1</a>. The figure presents the densities of the estimated coefficients across all simulations, whereas the table provides a brief summary of the bias and mean absolute error of the estimated coefficients.</p>
<div id="fig-cre" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="H">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cre-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="simulation/fig1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cre-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Estimated marginal effects/Coefficient densities for non-linear models
</figcaption>
</figure>
</div>
<p>As expected, controlling for the unobserved effects, the unfeasible estimator provides what we would consider to be the benchmark/true estimates of coefficients/marginal effects given the sample and data generating process. For <a href="#tbl-cre" class="quarto-xref">Table&nbsp;1</a>, we use the mean of the unfeasible estimator to represent the true point estimate and construct the bias and mean absolute error for the other estimators.</p>
<p>Because the individual effects are constructed to be correlated with the explanatory variables, the estimated coefficients are biased when they are ignored, and coefficients are estimated using pooled estimators. The magnitude of the bias is approximately 12-13% with respect to the point estimate of the coefficient or marginal effect.</p>
<p>On the other hand, the CRE approach seems to provide consistent estimates for the coefficients/marginal effects, with a distribution that is centered around the true point estimate, with slightly higher variance than the benchmark. Based on the results from <a href="#tbl-cre" class="quarto-xref">Table&nbsp;1</a>, the bias of the CRE approach is negligible, with a MAE that is about 20% to 30% larger than the benchmark.</p>
<div id="tbl-cre" class="quarto-float quarto-figure quarto-figure-center anchored" data-tbl-pos="H">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-cre-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Bias and MAE for the estimated marginal effects/Coefficients for non-linear models
</figcaption>
<div aria-describedby="tbl-cre-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Probit</th>
<th style="text-align: center;">FProbit</th>
<th style="text-align: center;">Tobit</th>
<th style="text-align: center;">Poisson</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>True:Bias</td>
<td style="text-align: center;">-0.000</td>
<td style="text-align: center;">-0.000</td>
<td style="text-align: center;">-0.000</td>
<td style="text-align: center;">-0.000</td>
</tr>
<tr class="even">
<td>True:MAE</td>
<td style="text-align: center;">0.014</td>
<td style="text-align: center;">0.031</td>
<td style="text-align: center;">0.043</td>
<td style="text-align: center;">0.022</td>
</tr>
<tr class="odd">
<td>Pool:Bias</td>
<td style="text-align: center;">0.037</td>
<td style="text-align: center;">0.087</td>
<td style="text-align: center;">0.130</td>
<td style="text-align: center;">0.134</td>
</tr>
<tr class="even">
<td>Pool:MAE</td>
<td style="text-align: center;">0.037</td>
<td style="text-align: center;">0.087</td>
<td style="text-align: center;">0.130</td>
<td style="text-align: center;">0.134</td>
</tr>
<tr class="odd">
<td>CRE:Bias</td>
<td style="text-align: center;">-0.001</td>
<td style="text-align: center;">-0.002</td>
<td style="text-align: center;">-0.001</td>
<td style="text-align: center;">0.005</td>
</tr>
<tr class="even">
<td>CRE:MAE</td>
<td style="text-align: center;">0.018</td>
<td style="text-align: center;">0.037</td>
<td style="text-align: center;">0.052</td>
<td style="text-align: center;">0.027</td>
</tr>
<tr class="odd">
<td><em>N</em></td>
<td style="text-align: center;">10000</td>
<td style="text-align: center;">10000</td>
<td style="text-align: center;">10000</td>
<td style="text-align: center;">10000</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="sec-5" class="level1">
<h1>Conclusion</h1>
<p>This paper introduces the <code>cre</code> command, a prefix-type command that facilitates the implementation of Correlated Random Effects (CRE) models with a wide range of official and user-written Stata estimation commands. The CRE approach offers a middle ground between fixed effects and random effects models, addressing some of their limitations, particularly in the context of nonlinear model estimation.</p>
<p>As previously discussed in the literature, our Monte Carlo simulations show that the CRE approach, implemented through the <code>cre</code> command, consistently estimates coefficients and marginal effects, performing comparably to the unfeasible estimators that directly control for unobserved factors. The simulations reveal negligible bias, with an increase in the variance of the estimates, which is consistent with theoretical expectations.</p>
<p>The <code>cre</code> command addresses a significant gap in Stata’s econometric toolkit, providing a user-friendly implementation of CRE models. This tool may prove valuable for researchers working with panel data or nested data structures, where standard fixed effects approaches may be challenging or nonexistent, and random effects assumptions are not appropriate.</p>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>StataNow released an option for the estimation of CRE models as part of the panel data estimators on June 25, 2024. There are also the community-contributed commands <code>xthybrid</code><span class="citation" data-cites="schunck2017">[@schunck2017]</span>, <code>mundlak</code><span class="citation" data-cites="perales2013">[@perales2013]</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>For time-invariant covariates, the RE estimator will be identical to <span class="citation" data-cites="chamberlain1982multivariate">@chamberlain1982multivariate</span> approach only<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>As described in <span class="citation" data-cites="rios2015">@rios2015</span>, it is possible to implement a within-transformation using an iterative demeaning process until convergence. More recently, StataNow 18.5 also released a command that allows for the estimation of M-way fixed effects using a similar (yet more efficient) approach.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>